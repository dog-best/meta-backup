[
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.assign_unique_public_uid()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  new_uid text;\r\nbegin\r\n  loop\r\n    new_uid := public.generate_public_uid();\r\n    exit when not exists (\r\n      select 1 from public.profiles where public_uid = new_uid\r\n    );\r\n  end loop;\r\n\r\n  new.public_uid := new_uid;\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.buy_airtime(p_user_account uuid, p_bills_account uuid, p_amount numeric, p_reference text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  perform post_transfer(\r\n    p_user_account,\r\n    p_bills_account,\r\n    p_amount,\r\n    p_reference,\r\n    jsonb_build_object('type','airtime')\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.create_bill_payment(p_user_id uuid, p_transaction_id uuid, p_category text, p_provider text, p_product text, p_customer_reference text, p_amount numeric)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  bill_id uuid;\r\nbegin\r\n  insert into bill_payments (\r\n    user_id,\r\n    transaction_id,\r\n    category,\r\n    provider,\r\n    product,\r\n    customer_reference,\r\n    amount,\r\n    status\r\n  )\r\n  values (\r\n    p_user_id,\r\n    p_transaction_id,\r\n    p_category,\r\n    p_provider,\r\n    p_product,\r\n    p_customer_reference,\r\n    p_amount,\r\n    'INITIATED'\r\n  )\r\n  returning id into bill_id;\r\n\r\n  return bill_id;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.credit_user_from_paystack(p_user_id uuid, p_amount numeric, p_reference text, p_raw jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  v_user_account uuid;\r\n  v_paystack_account uuid;\r\nbegin\r\n  if p_amount is null or p_amount <= 0 then\r\n    raise exception 'Invalid amount';\r\n  end if;\r\n\r\n  -- 1) Strong idempotency (prevents double-credit even under retries)\r\n  insert into public.idempotency_keys(key, scope)\r\n  values (p_reference, 'paystack_credit')\r\n  on conflict (key) do nothing;\r\n\r\n  if not found then\r\n    -- already processed\r\n    return;\r\n  end if;\r\n\r\n  -- 2) Record paystack transaction (unique ref)\r\n  insert into public.paystack_transactions(reference, user_id, amount, status, raw)\r\n  values (p_reference, p_user_id, p_amount, 'success', p_raw)\r\n  on conflict (reference) do nothing;\r\n\r\n  -- 3) Find ledger accounts\r\n  select id into v_user_account\r\n  from public.ledger_accounts\r\n  where owner_type='user' and owner_id=p_user_id and currency='NGN'\r\n  limit 1;\r\n\r\n  select id into v_paystack_account\r\n  from public.ledger_accounts\r\n  where owner_type='system' and account_type='paystack_clearing'\r\n  limit 1;\r\n\r\n  if v_user_account is null then\r\n    raise exception 'User wallet account not found';\r\n  end if;\r\n\r\n  if v_paystack_account is null then\r\n    raise exception 'Paystack clearing account not found';\r\n  end if;\r\n\r\n  -- 4) Credit: paystack_clearing -> user wallet\r\n  perform public.post_transfer(\r\n    p_from_account := v_paystack_account,\r\n    p_to_account   := v_user_account,\r\n    p_amount       := p_amount,\r\n    p_reference    := p_reference,\r\n    p_metadata     := jsonb_build_object('type','wallet_funding','source','paystack')\r\n  );\r\n\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.credit_user_from_paystack(p_user_account uuid, p_paystack_account uuid, p_amount numeric, p_reference text, p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  -- idempotency\r\n  if exists (\r\n    select 1 from transfers where reference = p_reference\r\n  ) then\r\n    raise exception 'Duplicate Paystack credit';\r\n  end if;\r\n\r\n  -- money enters system from Paystack\r\n  perform post_transfer(\r\n    p_paystack_account,\r\n    p_user_account,\r\n    p_amount,\r\n    p_reference,\r\n    p_metadata\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.credit_wallet(p_user_id uuid, p_amount numeric, p_reference text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  -- Prevent duplicate credits\r\n  if exists(select 1 from transactions where reference = p_reference) then\r\n    raise notice 'Duplicate reference, ignoring %', p_reference;\r\n    return;\r\n  end if;\r\n\r\n  update wallets\r\n  set balance = balance + p_amount\r\n  where user_id = p_user_id;\r\n\r\n  insert into transactions(wallet_id, amount, type, reference)\r\n  select id, p_amount, 'credit', p_reference\r\n  from wallets where user_id = p_user_id;\r\n\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.credit_wallet(p_user_id uuid, p_amount numeric, p_reference text, p_description text DEFAULT 'Wallet credit'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  insert into transactions (\r\n    user_id,\r\n    type,\r\n    amount,\r\n    reference,\r\n    status,\r\n    description\r\n  )\r\n  values (\r\n    p_user_id,\r\n    'CREDIT',\r\n    p_amount,\r\n    p_reference,\r\n    'SUCCESS',\r\n    p_description\r\n  );\r\n\r\n  update wallets\r\n  set balance = balance + p_amount,\r\n      updated_at = now()\r\n  where user_id = p_user_id;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.debit_wallet(p_user_id uuid, p_amount numeric, p_reference text, p_description text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  current_balance numeric;\r\nbegin\r\n  select balance into current_balance\r\n  from wallets\r\n  where user_id = p_user_id\r\n  for update;\r\n\r\n  if current_balance < p_amount then\r\n    raise exception 'INSUFFICIENT_BALANCE';\r\n  end if;\r\n\r\n  insert into transactions (\r\n    user_id,\r\n    type,\r\n    amount,\r\n    reference,\r\n    status,\r\n    description\r\n  )\r\n  values (\r\n    p_user_id,\r\n    'DEBIT',\r\n    p_amount,\r\n    p_reference,\r\n    'SUCCESS',\r\n    p_description\r\n  );\r\n\r\n  update wallets\r\n  set balance = balance - p_amount,\r\n      updated_at = now()\r\n  where user_id = p_user_id;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.generate_public_uid()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  chars text := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';\r\n  result text := '';\r\n  i int := 0;\r\nbegin\r\n  for i in 1..8 loop\r\n    result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);\r\n  end loop;\r\n  return result;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  insert into public.profiles (id, email)\r\n  values (new.id, new.email)\r\n  on conflict (id) do nothing;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.handle_new_user_wallet()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  insert into public.wallets (user_id, balance, currency)\r\n  values (new.id, 0, 'NGN');\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.post_transfer(p_from_account uuid, p_to_account uuid, p_amount numeric, p_reference text, p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  sender_balance numeric;\r\nbegin\r\n  -- Idempotency\r\n  if exists (\r\n    select 1 from transfers where reference = p_reference\r\n  ) then\r\n    raise exception 'Duplicate transfer reference';\r\n  end if;\r\n\r\n  -- Balance check\r\n  select balance into sender_balance\r\n  from account_balances\r\n  where account_id = p_from_account;\r\n\r\n  if sender_balance is null or sender_balance < p_amount then\r\n    raise exception 'Insufficient balance';\r\n  end if;\r\n\r\n  -- Record transfer\r\n  insert into transfers (\r\n    from_account,\r\n    to_account,\r\n    amount,\r\n    currency,\r\n    status,\r\n    reference,\r\n    metadata\r\n  ) values (\r\n    p_from_account,\r\n    p_to_account,\r\n    p_amount,\r\n    'NGN',\r\n    'completed',\r\n    p_reference,\r\n    p_metadata\r\n  );\r\n\r\n  -- Debit sender\r\n  insert into ledger_entries (\r\n    account_id,\r\n    direction,\r\n    amount,\r\n    reference,\r\n    metadata\r\n  ) values (\r\n    p_from_account,\r\n    'debit',\r\n    p_amount,\r\n    p_reference,\r\n    p_metadata\r\n  );\r\n\r\n  -- Credit receiver\r\n  insert into ledger_entries (\r\n    account_id,\r\n    direction,\r\n    amount,\r\n    reference,\r\n    p_metadata\r\n  ) values (\r\n    p_to_account,\r\n    'credit',\r\n    p_amount,\r\n    p_reference,\r\n    p_metadata\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.purchase_bill(p_user_account uuid, p_bills_account uuid, p_amount numeric, p_reference text, p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  -- ensure idempotency\r\n  if exists (\r\n    select 1 from transfers where reference = p_reference\r\n  ) then\r\n    raise exception 'Duplicate bill payment';\r\n  end if;\r\n\r\n  -- debit user, credit system\r\n  perform post_transfer(\r\n    p_user_account,\r\n    p_bills_account,\r\n    p_amount,\r\n    p_reference,\r\n    p_metadata\r\n  );\r\nend;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.sum_ledger_by_metadata_type(p_type text, p_date date)\n RETURNS numeric\n LANGUAGE sql\nAS $function$\r\n  select coalesce(sum(amount), 0)\r\n  from ledger_entries\r\n  where metadata->>'type' = p_type\r\n    and created_at::date = p_date;\r\n$function$\n"
  },
  {
    "function_sql": "CREATE OR REPLACE FUNCTION public.sum_ledger_by_reference_prefix(p_prefix text, p_date date)\n RETURNS numeric\n LANGUAGE sql\nAS $function$\r\n  select coalesce(sum(amount), 0)\r\n  from ledger_entries\r\n  where reference like p_prefix || '%'\r\n    and created_at::date = p_date;\r\n$function$\n"
  }
]